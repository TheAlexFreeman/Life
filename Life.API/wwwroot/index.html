<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Game of Life</title>
    <link rel="stylesheet" href="site.css" />

    <!--<link rel="apple-touch-icon" sizes="57x57" href="/favicon/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/favicon/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/favicon/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/favicon/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/favicon/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/favicon/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/favicon/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/favicon/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/favicon/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="/favicon/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/favicon/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon/favicon-16x16.png">
    <link rel="manifest" href="/favicon/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">-->
</head>

<body>
    <h1 id="life-title">Conway's Game of LIFE</h1>
    <hr />

    <a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">
        <h3>From Wikipedia</h3>
    </a>
    <p>
        The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John
        Horton
        Conway in 1970. It is a zero-player game, meaning that its evolution is determined by its initial state,
        requiring no further input. One interacts with the Game of Life by creating an initial configuration and
        observing how
        it evolves. It is Turing complete and can simulate a universal constructor or any other Turing machine.
    </p>

    <p>
        The universe of the Game of Life is an infinite, two-dimensional orthogonal grid of square cells, each of which
        is in
        one of two possible states, live or dead (or populated and unpopulated, respectively). Every cell interacts with
        its
        eight neighbours, which are the cells that are horizontally, vertically, or diagonally adjacent. At each step in
        time,
        the following transitions occur:
    </p>

    <ul>
        <li>
            <strong>Any <em>live</em> cell with <em>fewer than two</em> live neighbours dies</strong>, as if by
            underpopulation.
        </li>
        <li>
            <strong>Any <em>live</em> cell with <em>two or three</em> live neighbours lives on</strong> to the next
            generation.
        </li>
        <li>
            <strong>Any <em>live</em> cell with <em>more than three</em> live neighbours dies</strong>, as if by
            overpopulation.
        </li>
        <li>
            <strong>Any <em>dead</em> cell with <em>exactly three</em> live neighbours becomes a live cell</strong>, as
            if by reproduction.
        </li>
    </ul>
    <p>These rules, which compare the behavior of the automaton to real life, can be condensed into the following:</p>

    <ul>
        <li><strong>Any live cell with two or three live neighbours survives.</strong></li>
        <li><strong>Any dead cell with three live neighbours becomes a live cell.</strong></li>
        <li><strong>All other live cells die in the next generation.</strong></li>
        <li>Similarly, all other dead cells stay dead.</li>
    </ul>
    <p>
        The initial pattern constitutes the seed of the system. The first generation is created by applying the above
        rules
        simultaneously to every cell in the seed, live or dead; births and deaths occur simultaneously, and the discrete
        moment
        at which this happens is sometimes called a tick. Each generation is a pure function of the preceding one. The
        rules continue to be applied repeatedly to create further generations.
    </p>

    <hr />
    <div id="grid-container">
        <div id="grid-actions">
            <div id="grid-size">
                <label for="width">
                    Board Width:
                    <input id="width" type="number" value="150" />
                </label>
                <label for="height">
                    Board Height:
                    <input id="height" type="number" value="150" />
                </label>
                <button onclick="updateSize()">Update Board Size</button>
                <button id="clear-board" onclick="clearBoard()">Clear Board</button>
            </div>

            <br>

            <span id="grid-library" onmouseout="INPUT.blurMenu()">
                <label for="pattern-name">
                    Pattern Name:
                    <input id="pattern-name" type="text" />
                </label>
                <button onclick="savePattern()">Save Current Board</button>
                <label for="pattern-menu">
                    Saved Patterns:
                    <select id="pattern-menu" onfocus="getPatterns()" onblur="loadPattern()">
                        <option disabled selected value="">No patterns available</option>
                    </select>
                </label>
            </span>

            <label for="borders"> Borders:
                <input id="borders" type="checkbox" onchange="updateBorders()" />
            </label>

            <span id="grid-colors">
                <label for="cell-color">
                    Cell Color: <input id="cell-color" type="color" value="#32cd32" onchange="updateCellColor()" />
                </label>
                <label for="background-color">
                    Background Color: <input id="background-color" type="color" value="#d3d3d3"
                        onchange="updateBackgroundColor()" />
                </label>
            </span>
        </div>

        <div id="game-buttons">
            <button onclick="back()">&lt;&lt;&lt;</button>
            <button onclick="tick()">&gt;&gt;&gt;</button>
        </div>

        <div id="game-stats">
            Generations: <span id="gen-counter">0</span>
            <br>
            Population: <span id="pop-counter">0</span>
        </div>

        <div id="grid">
        </div>
    </div>


    <hr />
    <table>
        <thead>
            <tr>
                <td></td>
                <td></td>
                <td></td>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td></td>
                <td></td>
                <td></td>
            </tr>
        </tbody>
    </table>

    <script src="points.js" asp-append-version="true"></script>
    <script src="game.js" asp-append-version="true"></script>
    <script src="grid.js" asp-append-version="true"></script>
    <script src="api.js" asp-append-version="true"></script>
    <script src="input.js" asp-append-version="true"></script>
    <script src="site.js" asp-append-version="true"></script>

    <script type="text/javascript">
        const INPUT = new InputHandler();
        const GAME = new Game(INPUT.size);
        const GRID = new Grid(INPUT.size);

        getPatterns();

        function clearBoard() {
            INPUT.clear();
            GAME.clear();
            GRID.clear();
        }

        function updateSize() {
            GAME.setSize(INPUT.size);
            GRID.setSize(INPUT.size);
        }

        function updateCellColor() {
            GRID.setCellColor(INPUT.cellColor);
        }

        function updateBackgroundColor() {
            GRID.setBackgroundColor(INPUT.backgroundColor);
        }

        function updateBorders() {
            GAME.setBorders(INPUT.borders);
            GRID.setBorders(INPUT.borders);
        }

        function tick() {
            const changes = GAME.tick();
            MEMORY.addTick(changes);
            for (let { x, y } of changes) {
                GAME.toggleCell({ x, y });
                GRID.toggleCell(x, y);
            }
        }

        function back() {
            const changes = MEMORY.back();
            if (changes[0] === null) {
                changes.shift();
            }
            for (let { x, y } of changes) {
                GAME.toggleCell({ x, y });
                GRID.toggleCell(x, y);
            }
        }

        function getPatterns() {
            apiGetAllPatterns()
                .then(patterns => INPUT.setupMenu(patterns));
        }

        function savePattern() {
            const { name, creator, points } = INPUT.validatePattern();
            apiSavePattern(name, creator, points)
                .then(pattern => INPUT.addMenuOption(pattern))
                .catch(error => console.error(`Unable to save pattern ${name}. `, error));
        }

        function loadPattern() {
            const id = INPUT.patternId;
            if (id) {
                apiLoadPattern(id)
                    .then(pattern => {
                        INPUT.previewPattern = pattern;
                        ACTIONS.configureCellEventHandlers(INPUT.cellEventHandlers);
                    })
                    .then(pattern => ACTIONS.setPreviewPattern(pattern))
                    .catch(error => console.error(`Unable to load pattern ${id}. `, error));
            } else {
                ACTIONS.resetCellEventHandlers();
            }
        }
    </script>
</body>

</html>